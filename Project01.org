#+TITLE: DM1 Project 01
#+LANGUAGE: en
#+OPTIONS: H:4 num:nil toc:nil \n:nil @:t ::t |:t ^:t *:t TeX:t LaTeX:t
#+OPTIONS: html-postamble:nil
#+STARTUP: showeverything entitiespretty
#+SETUPFILE: ../theme-bigblow.setup

Contributors: Paul Land, Nicki Caswell, Kathryn Hollingshead

* Common Core 
** Basic Cryptographic Methods / Definitions
   ●	Confidentiality
   ○	This is the concept of ensuring that data is not readable or useable by 
      unauthorized users.
      
   ●	Integrity
   ○	This is the protection of data from manipulation. It is the concept of 
      making sure data has not been modified.

   ●	Non-repudiation
   ○	This describes when a user is unable to say that they did not do 
      something after they have done it. It is like a signature of 
      authentication that shows that a person performed or approved an action.

   ●	Authentication
   ○	This is the proving of an identity of someone. This can be by showing 
      physical credentials like an ID card, using an authentication key, or 
      entering a password.

   ●	Steganography
   ○	This is the concealing or hiding of messages. It can be done in many 
      different ways such as using invisible inks or even typing messages 
      with the text being the same color as the background.

   ●	Cryptography
   ○	The art and science of hiding messages and securing communication so 
      that only authorized people receive the communication.

   ●	Symmetric-key
   ○	This is when the same key is used to encrypt and decrypt a message. 
      A user will use an encryption key to encrypt a message, and the person 
      that receives the message must use that same key to decrypt it.

   ●	Block Ciphers
   ○	This is a method of encrypting plaintext by applying an algorithm with 
      an cryptographic key to a block of bits rather than one at a time.

   ●	Stream Ciphers
   ○	This is a method of encrypting plaintext by applying an algorithm with 
      an cryptographic key one bit at a time. It uses a pseudorandom stream 
      of bits for the key. 

   ●	Public Key
   ○	A public key is a key that can be used by anyone to encrypt a message, 
      but the message cannot be decrypted using the public key.

   ●	Private Key
   ○	A private key is used by a person to decrypt messages that were encrypted 
      using that person’s public key. This ensures that only the holder of the 
      private key is able to read the messages encrypted with the public key.

   ●	The Enigma Machine
   ○	This was a mechanical, typewriter-like machine used by the Germans during 
      World War II to encrypt messages for the German army.

   ●	True Randomness
   ○	This is randomness that has absolutely no logical or intellectual 
      reasoning for a sequence. There is not pattern or predictability. True 
      randomness cannot be calculated, so in software and cryptography, 
      pseudorandomness is used to calculate or produce seemingly random data.

   ●	Kerckhoff’s Principle
   ○	A cryptographic system should remain secure even if unauthorized people 
      were to know everything about the system besides the key.

   ●	Ciphertext
   ○	This is a message in its encrypted form.

   ●	Plaintext
   ○	This is a message as it is intended to be read or otherwise consumed. 
      It is how a message is before being encrypted into what is seemingly 
      gibberish.

   ●	Digital Signature
   ○	This is a mathematical scheme for proving that electronics messages or 
      documents are authentic.

   ●	GPG
   ○	GNU Privacy Guard is a hybrid-encryption software used for secure key 
      exchange.

   ●	HSM
   ○	A Hardware Security Module is a physical computing device that is used 
      for managing digital cryptokeys and can do cryptoprocessing.

   ●	SHA
   ○	The Secure Hashing Algorithms are a family of hashing algorithms that are 
      that are used for encrypting data.
      https://en.wikipedia.org/wiki/Secure_Hash_Algorithms

   ●	Key Exchange
   ○	This is a way to have secure communications by exchanging encryption 
      keys that are public and private in order to establish a secure line of 
      communication without. This describes any method that is used to do 
      secure key exchange.

** The Enigma Machine
   *Which two groups cracked it?* 
   
   A Polish group and a British group cracked the Enigma machine at different 
   times.
   
   The most well known codebreakers for the Polish group are Jerzy Rozycki, 
   Henryk Zygalski, and Marian Rejewski. These men were mathematicians that 
   were hired to work for the Polish General Staff's Cipher Bureau. Initially 
   mathematicians were not used to break code, but the Polish thought it 
   might be a good idea and tried it out. 

   The British later hired mathematicians to help with code breaking. As a 
   result, the British group came to consist of Alan Turing, Gordon Welchman, 
   and a few other people who also worked at Bletchley Park.
 
   *Who did it first?*
   
   The Polish group cracked the Enigma Machine first in 1932 while the British 
   group did not have success with cracking the Enigma Machine until 1940.
   
   *What is the method each group used?*
   
   The Polish group focused on a mathematical approach to break the Enigma 
   Machine. They first used the characteristics method to find patterns  
   from some of the German message senders. This helped them to be able to solve 
   the six permutations that the Germans used to encipher their messages or in 
   other words find the key to the cipher. No information was needed about the 
   machine in order to accomplish this. 

   Next they used the Theory of Permutations and Groups along with the help of 
   two German Engima manuals and two pages of monthly keys to find out how the 
   Enigma scrambler was wired. Rejewski later found that the military Enigma 
   that the Germans were using was not the same as the commercial Enigma they 
   had access to. As a result the ring and keyboard settings were different. 
   He guessed that the order was alphabetical and was correct. With this 
   information they were able to make replicas of the Engima machine called 
   "Enigma doubles". 

   Next they used the grill method to find the daily keys for the ciphers as 
   well as use this method to find the rightmost rotor and its position. The 
   grill method was also used to determine the plugboard wiring. They next set 
   out to use a cycle-length method instead of a grill method in order to find 
   cycles in the permutations. This resulted in them working to make a card 
   catalog to index the cycle-lengths which lead to the creation of a 
   cyclometer which was used to make the catalog. 

   When the characteristics method no longer worked for getting the message key, 
   they were able to use the Zygalski sheet method instead. This used perforated
   sheets to find the possible six wheel orders. This method uses the occurences
   of females. Females occur when the message key is given twice but is 
   enciphered differently and there is a letter that occurs twice and in the 
   same place as in the previous message key. For example, if the plaintext is 
   ABC and the cipher text (message key), being sent twice, is PCK ZEK 
   (PCK = ABC and ZEK = ABC), then a female has occurred because K showed up 
   twice and in the same position (third position in this case). 

   They later resorted to using an electro-mechanical device called the Bomba 
   which was invented by Rejewski. The Bomba used females to get key message, 
   but only needed an occurence of 3 females to uncode the message key instead 
   of the 10 females that the Zygalski sheet method needed to solve the same 
   problem. 

   
   The British group were given information from the Polish before the war 
   began. This greatly helped the British in breaking the Enigma machine. 
   Turing used the crib (known or guessed plaintext found in an encrypted 
   method) to solve the Enigma machine. The crib that was found would later 
   be used with an electro-mechanical device that Turing based off of the Bomba. 
   This machine would compare a crib to a ciphertext based off of the wheel 
   order that was set. Its function was to stop when a contradiction wasn't 
   present between the crib and the ciphertext. This would minimize the 
   possibilities to what the solution was and eventually lead to the "correct 
   plaintext of the whole message" [1]. 
   
   Turing also used probability analysis to estimate the "number of stops per 
   rotor order" [1] in order to avoid wasting time on menus (specified 
   relationship of the cib and ciphertext) that "were likely to yield to an 
   excessive number of false stops" [1]. Later Welchman invented a diagnol 
   board that increased the "number of steps needed for the codebreaking 
   effort" [2].

   Sources: 
   
   [1] https://en.wikipedia.org/wiki/Cryptanalysis_of_the_Enigma
   
   [2] http://www.cryptomuseum.com/crypto/bombe/index.htm

   [3] https://www.codesandciphers.org.uk/virtualbp/poles/poles.htm
   

** Password Strength Security
*** DONE Checker Implementation - ELISP
    CLOSED: [2018-06-14 Thu 21:52]

#+BEGIN_SRC elisp :results silent 
(defun upperp (p)
 (setq upper (upcase p))
  (string-equal upper p))
#+END_SRC

#+BEGIN_SRC elisp :results silent
(defun lowerp (p)
 (setq lower (downcase p))
  (string-equal lower p))
#+END_SRC

#+BEGIN_SRC elisp :results silent
(defun digitp (p)
 (or (string-equal "0" p)(string-equal "1" p)(string-equal "2" p)
      (string-equal "3" p)(string-equal "4" p)(string-equal "5" p)
      (string-equal "6" p)(string-equal "7" p)(string-equal "8" p)
      (string-equal "9" p)))
#+END_SRC

#+BEGIN_SRC elisp :results silent
(defun passwordCheck(p)
 (setq low 0)
 (setq up 0)
 (setq digit 0)
 (setq symb 0)
 (setq count 0)
 (setq checksPerSec 588235) 
 (while (< count (length p))
  (setq c (substring p count (+ count 1)))
  (if (lowerp c) (setq low 26)
   (if (upperp c) (setq up 26)
    (if (digitp c) (setq digit 10) (setq symb 33))))
  (incf count))
 (setq totalUniqueSymbols (+ low up digit symb))
 (setq numPermutations (expt totalUniqueSymbols (length p))) 
 (setq secondsToCrack (/ numPermutations checksPerSec))
 (setq halfSeconds (/ secondsToCrack 2))
 (setq secPerYear (* 525600 60))
 (setq years (/ halfSeconds secPerYear))
 (if (< years 1) "Very weak password" 
  (if (< years 25) "Weak password"
   (if (< years 50) "Average password"
    (if (< years 75) "Strong password" "Very Strong Password")))))
#+END_SRC

#+BEGIN_SRC elisp :results output
(print(passwordCheck "@ApplesAuce20&"))
#+END_SRC

#+RESULTS:
: 
: "Very Strong Password"

** Caesar Cipher
*** Implementation - ELISP
#+BEGIN_SRC elisp
(defun caesar (plainText key)
(setq alpha "abcdefghijklmnopqrstuvwxyz")
(setq encrypt "")
(setq num 0)
(while (< num (length plainText))
  (setq c (downcase (substring plainText num (+ num 1))))
  (setq start (% (+ (- (aref c 0) 97) key) (length alpha)))
  (setq encrypt (concat encrypt (substring alpha start (+ start 1))))
  (princ (substring encrypt num (+ num 1)))
  (incf num)))
#+END_SRC

#+RESULTS:
: caesar

#+BEGIN_SRC elisp :results output
(setq plainText "hello world")
(setq key 5)

(caesar plainText key)
#+END_SRC

#+RESULTS:
: mjqqtsbtwqi

#+BEGIN_SRC python :results output

# Paul's python stuff. Can be ignored.
def caesar(text, shift):
    abc = "a~b!c@d#e)f?g%h$i(.j;k l^m*n&o+=p{q]r}s[t,u<v> w\"x\'y\\z"
    cipher = {}


    for i in range(0, len(abc)):
        cipher[abc[i]] = abc[(i + shift) % len(abc)]

    cipherText = ""

    for c in text:
        cipherText += cipher[c]
    return cipherText

# This is to test the ceasar cipher
cipher_text = caesar("cout << \"hello world\" << endl;", 5)
print(cipher_text)
plain_text = caesar(cipher_text, -5)
print(plain_text)
#+END_SRC

#+RESULTS:
: )qw>y""yzj%&&qy\q,&?zy""y%p?&m
: cout << "hello world" << endl;

** Vigenere Cipher
*** Implementation - ELISP
#+BEGIN_SRC elisp
(defun vigenere (plainText key)

(setq alpha "abcdefghijklmnopqrstuvwxyz")
(setq encrypt "")

(setq num 0)
(while (< num (length plainText))
  (setq c (downcase (substring plainText num (+ num 1))))
  (setq shiftIt (% num (length key))) ;index of key that determines shift
  (setq shift (- (aref  key shiftIt) 97)) ;amount to shift plainText by
  (setq start (% (+ (- (aref c 0) 97) shift) 26)) ;index of alpha
  (setq encrypt (concat encrypt (substring alpha start (+ start 1))))
  (princ (substring encrypt num (+ num 1)))
  (incf num))
)
#+END_SRC

#+RESULTS:
: vigenere

#+BEGIN_SRC elisp :results output 
(setq plainText "HelloMyNameIsInigo")
(setq key "abcdef")

(vigenere plainText key)
#+END_SRC

#+RESULTS:
: hfnosryocpinsjplkt

** RSA Theory and Understanding
*** Number Theory Principles Involved
    First, let's explain RSA on a high level. RSA uses two keys for encryption:
    a public key and a private key. Both of these keys can be used for encrypting
    and decrypting messages, but they can only be used for one or the other on a 
    particular message. We'll get into the details of how those keys are generated
    later, but for now let's discuss how the encryption process works overall.

    Let's say that Paul has a message that he needs to email to Kathryn. If Paul
    wanted to encrypt this message so that only Kathryn could read it, he would
    use Kathyrn's public key to encrypt the message. Since the message has been
    encrypted using the public key, only Kathryn's private key will be able to 
    decrypt the message. As long as Kathryn keeps her private key a secret, no
    one else will be able to decrypt messages that are sent to her.

    Now let's suppose Kathryn needed to send out an important message, but she
    also wanted others to be able to verify that the message came from her.
    Kathryn would be able to encrypt her message using her private key, and 
    everyone else would be able to decrypt the message using her public key that
    is freely available. Since the message was able to be decrypted using Kathryn's
    public key, it verifies that the message came from her!

    This encryption using private and public keys is like having a mailbox that
    other's can put letters into while you have the only key to open the mailbox
    and get the letters inside. The mailbox is like your public key and the key
    to your mailbox is like the private key.

    Now let's discuss how the keys are securely generated.

* Option 1
  *Modern Software Applications*
  
  Purpose - apply discrete mathematics directly into a current industry and 
  build a portfolio worthy project.
 
** Caesar or Vigenere Cipher Proof of Insecurity
** One Other Classic Cipher
*** Trifid - Kathryn Hollingshead and Paul Land
    *Research*
    
    The trifid cipher was created around 1902 by Felix Delastelle. This cipher 
    is similar to the bifid cipher, which Felix had created in previous years. 
    The difference between the bifid and the trifid is that the bifid uses a 
    5x5 square (also known as a Polybius square) or a 6x6 square to create 
    coordinates for each symbol/letter used in the plaintext. The trifid uses 
    a 3x3x3 cube to turn each symbol/letter into coordinates. Both of these also 
    use transposition to further encrypt the symbols/letters used for ciphering 
    the plaintext. 

    The trifid requires the use of a mixed alphabet with one symbol to have a 
    total of 27 letters. The alphabet can be mixed in any way but the 
    traditional way is to use a keyword or phrase to mix up the letters. This is 
    done by taking the keyword (ex. BOBBY) and then, in order, take the unique 
    letters (ex. BOY) and use them as the beginning of the mixed alphabet. Then 
    follow the unique letters with the rest of the alphabet in its natural 
    order (ex. BOYACDEFGHIJKLMNPQRSTUVWXZ#). The symbol at the end can be any 
    type of symbol. Some people use a period (.), a pound symbol (#), or follow 
    Felix in using a plus sign (+). 

    After a mixed alphabet has been created, it is placed into three separate 
    layers that are each composed into a 3x3 grid. The mixed alphabet is then 
    placed in the first layer until one row at a time starting from the top row 
    to the bottom row until the entire grid for that layer is filled. This 
    repeats for the next two layers starting from where the last layer left off. 
    
    Ex. 
        |   | Layer 1   |   |   | Layer 2   |   |   | Layer 3   |
        _________________________________________________________
        |   | 1 | 2 | 3 |   |   | 1 | 2 | 3 |   |   | 1 | 2 | 3 |
        | 1 | B | O | Y |   | 1 | H | I | J |   | 1 | R | S | T |
        | 2 | A | C | D |   | 2 | K | L | M |   | 2 | U | V | W |
        | 3 | E | F | G |   | 3 | N | P | Q |   | 3 | X | Z | # |

    These layers allow us to find the coordinates, or numbers, that represent 
    each letter and allow us to follow through with encrypting the plaintext. 
    
    Ex. 
        |Mixed Alphabet| B O Y A C D E F G H I J K L M N P Q R S T U V W X Z # |
        |Layer #       | 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 |
        |Row #         | 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 |
        |Column #      | 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 |

    The plaintext can now be represented by each letter's associated set of 
    numbers in a vertical manner. 
    
    Ex. Plaintext: This is a story

        | T H I S I S A S T O R Y |
        | 3 2 2 3 2 3 1 3 3 1 3 1 |
        | 1 1 1 1 1 1 1 1 1 1 1 1 | 
        | 3 1 2 2 2 2 1 2 3 2 1 3 |

    A period length of 5 - 20 is generally used to divide the plaintext and 
    its associated set of numbers into groups. 

    Ex. Period length: 5

        | T H I S I | S A S T O | R Y |
        | 3 2 2 3 2 | 3 1 3 3 1 | 3 1 |
        | 1 1 1 1 1 | 1 1 1 1 1 | 1 1 |
        | 3 1 2 2 2 | 2 1 2 3 2 | 1 3 |

        The last group (R Y) has a period length of 2 because there are not 
        enough letters to extend it to a period of 5. 
        
    Each group is now read hoizontally in groups of 3. The entire group 
    must be read before moving onto the next group. If there are not enough 
    numbers on a line to finish a group of three within the main group, then 
    the beginning numbers on the next line down are taken from that line 
    and are grouped with the ones above to complete a group of three numbers. 

    Ex. 
        | Group 1   | Group 2   | Group 3|
        | T H I S I | S A S T O | R Y    |
        | 3 2 2 3 2 | 3 1 3 3 1 | 3 1    |
        | 1 1 1 1 1 | 1 1 1 1 1 | 1 1    |
        | 3 1 2 2 2 | 2 1 2 3 2 | 1 3    |


        |Group 1| 3 2 2 | 3 2 1 | 1 1 1 | 1 3 1 | 2 2 2 |
        |Group 2| 3 1 3 | 3 1 1 | 1 1 1 | 1 2 1 | 2 3 2 |
        |Group 3| 3 1 1 | 1 1 3 |

    Next we translate all the three digit codes in each main group to their 
    respective letter according to our original mapping. 

    Ex. 
        |Mixed Alphabet| B O Y A C D E F G H I J K L M N P Q R S T U V W X Z # |
        |Layer #       | 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 |
        |Row #         | 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 1 1 1 2 2 2 3 3 3 |
        |Column #      | 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 |


        | Group 1 | V | U | B | E | L |
        | Group 2 | T | R | B | A | P |
        | Group 3 | R | Y |

    Now we must group the new letters into groups of five.

    Ex. Plaintext:  This is a story
        Ciphertext: VUBEL TRBAP RY

    To decrypt the ciphertext, you need to take the cipertext and write out each 
    letter's associated number set horizontally using the original period length.
    And then translate each column to its associated letter. 

     Ex. 
         |         |   V   |   U   |   B   |   E   |   L   |
         | Group 1 | 3 2 2 | 3 2 1 | 1 1 1 | 1 3 1 | 2 2 2 |


         |         |   T   |   R   |   B   |   A   |   P   |
         | Group 2 | 3 1 3 | 3 1 1 | 1 1 1 | 1 2 1 | 2 3 2 |


         |         |   R   |   Y   |
         | Group 3 | 3 1 1 | 1 1 3 |


         | Group 1   | Group 2   | Group 3 |
         | 3 2 2 3 2 | 3 1 3 3 1 | 3 1     |
         | 1 1 1 1 1 | 1 1 1 1 1 | 1 1     |
         | 3 1 2 2 2 | 2 1 2 3 2 | 1 3     |
         | T H I S I | S A S T O | R Y     |


    *Theory*



    *Implementation*

 #+BEGIN_SRC python :results output
def index(row, column):
    return 3 * row + column

def trifid(plainText, key):
    # Remove the plaintext spaces and make uppercase
    plainText = plainText.replace(" ", "")   
    plainText = plainText.upper()

    abc = "ABCDEFGHIJKLMNOPQRSTUVWXYZ#"

    # Remove the key spaces and make uppercase
    key = key.remove(" ", "")
    key = key.upper()
   
    # Set for the cipher key
    keySet = []

    # Add all of the unique letters from the key to the key set
    for c in key:
        if c not in keySet:
            keySet.append(c)

    # Add the rest of the alphabet to the key set.
    for c in abc:
        if c not in keySet:
            keySet.append(c)
    
        
    # Set up the 3x3 layers matrices
    layer1 = []
    layer2 = []
    layer3 = []
    for i in range(0, 9):
        layer1.append(keySet.pop())
    for i in range(0, 9):
        layer2.append(keySet.pop())
    for i in range(0, 9):
        layer3.append(keySet.pop())
    
    letterToNum = {} 
    numToLetter = {}
    for c in abc:
        for row in range(0, 3):
            for col in range(0, 3):
                if c in layer1:
                    if layer1[index(row, col)] == c:
                        num = "1"
                        num += str(row)
                        num += str(col)
                        letterToNum[c] = num
                        numToLetter[num] = c
                        row = 4
                        col = 4
                elif c in layer2:
                    if layer2[index(row, col)] == c:
                        num = "2"
                        num += str(row)
                        num += str(col)
                        letterToNum[c] = num
                        numToLetter[num] = c
                        row = 4
                        col = 4
                elif c in layer3:
                    if layer3[index(row, col)] == c:
                        num = "3"
                        num += str(row)
                        num += str(col)
                        letterToNum[c] = num
                        numToLetter[num] = c
                        row = 4
                        col = 4

        


#+END_SRC 

   #+RESULTS:

*** Myszkowski - Justin Bengtson and Nicki Caswell
    -Research
    
    -Theory
    
    -Implementation
    
*** Nicodemus - Taylor Matheny and Ryan Davis
    -Research
    
    -Theory
    
    -Implementation

** RSA
*** Implementation (C++ or Python)
*** Questions with Solutions
*** Key Terms
*** Examples

** AES
   *What is this and how does it work?*
   
   AES stands for Advanced Encryption Standard and is a symmetric block cipher used by the U.S.
   Government to protect classified information. It is used throughout the world to encrypt sensitive
   data. AES uses symmetric key algorithm (Rijndael), and becamse thr first publicly accessible and open cipher
   approved by the NSA for top-secret information.
   
   *So how does AES work?*
   
   It comprises three cipher blocks: AES-128, AES-192 and AES-256, which each encrypt and decrypt data in
   blocks of 128 bits using cryptographic keys of 128-, 192- and 256-bits.
   When sending a message, the user and the sender must both know a "secret key" in order to encrypt and
   decrypt the message.
   
   The first step of the cipher is to put the data into an array, after which the cipher transformations are
   repeated over a number of encryption rounds. The number of rounds is determined by the key length.
   
   In the first round of transformation, a substitution table is used to "substitute" the data. The second
   round of transformation shifts the data rows and the third round mixes up the columns. The final transformation
   uses the XOR operator on each colum with a different part of the encryption key. Therefore, longer keys
   need more rounds to complete.
   
   AES has proven to be a reliable cipher and the only practical, successful attacks against AES have
   leveraged side-channel attacks on weaknesses found in the implemenation or key manafement of specific AES-based
   encryption products.
   
** Cryptanalysis
   Decipher two cipher texts using an algorithm.
