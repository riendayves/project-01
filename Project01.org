#+TITLE: DM1 Project 01
#+LANGUAGE: en
#+OPTIONS: H:4 num:nil toc:nil \n:nil @:t ::t |:t ^:t *:t TeX:t LaTeX:t
#+OPTIONS: html-postamble:nil
#+STARTUP: showeverything entitiespretty
#+SETUPFILE: ../theme-bigblow.setup

Contributors: Paul Land, Nicki Caswell

* Common Core 
** Basic Cryptographic Methods / Definitions
   ●	Confidentiality
   ○	This is the concept of ensuring that data is not readable or useable by 
      unauthorized users.
      
   ●	Integrity
   ○	This is the protection of data from manipulation. It is the concept of 
      making sure data has not been modified.

   ●	Non-repudiation
   ○	This describes when a user is unable to say that they did not do 
      something after they have done it. It is like a signature of 
      authentication that shows that a person performed or approved an action.

   ●	Authentication
   ○	This is the proving of an identity of someone. This can be by showing 
      physical credentials like an ID card, using an authentication key, or 
      entering a password.

   ●	Steganography
   ○	This is the concealing or hiding of messages. It can be done in many 
      different ways such as using invisible inks or even typing messages 
      with the text being the same color as the background.

   ●	Cryptography
   ○	The art and science of hiding messages and securing communication so 
      that only authorized people receive the communication.

   ●	Symmetric-key
   ○	This is when the same key is used to encrypt and decrypt a message. 
      A user will use an encryption key to encrypt a message, and the person 
      that receives the message must use that same key to decrypt it.

   ●	Block Ciphers
   ○	This is a method of encrypting plaintext by applying an algorithm with 
      an cryptographic key to a block of bits rather than one at a time.

   ●	Stream Ciphers
   ○	This is a method of encrypting plaintext by applying an algorithm with 
      an cryptographic key one bit at a time. It uses a pseudorandom stream 
      of bits for the key. 

   ●	Public Key
   ○	A public key is a key that can be used by anyone to encrypt a message, 
      but the message cannot be decrypted using the public key.

   ●	Private Key
   ○	A private key is used by a person to decrypt messages that were encrypted 
      using that person’s public key. This ensures that only the holder of the 
      private key is able to read the messages encrypted with the public key.

   ●	The Enigma Machine
   ○	This was a mechanical, typewriter-like machine used by the Germans during 
      World War II to encrypt messages for the German army.

   ●	True Randomness
   ○	This is randomness that has absolutely no logical or intellectual 
      reasoning for a sequence. There is not pattern or predictability. True 
      randomness cannot be calculated, so in software and cryptography, 
      pseudorandomness is used to calculate or produce seemingly random data.

   ●	Kerckhoff’s Principle
   ○	A cryptographic system should remain secure even if unauthorized people 
      were to know everything about the system besides the key.

   ●	Ciphertext
   ○	This is a message in its encrypted form.

   ●	Plaintext
   ○	This is a message as it is intended to be read or otherwise consumed. 
      It is how a message is before being encrypted into what is seemingly 
      gibberish.

   ●	Digital Signature
   ○	This is a mathematical scheme for proving that electronics messages or 
      documents are authentic.

   ●	GPG
   ○	GNU Privacy Guard is a hybrid-encryption software used for secure key 
      exchange.

   ●	HSM
   ○	A Hardware Security Module is a physical computing device that is used 
      for managing digital cryptokeys and can do cryptoprocessing.

   ●	SHA
   ○	The Secure Hashing Algorithms are a family of hashing algorithms that are 
      that are used for encrypting data.

   ●	Key Exchange
   ○	This is a way to have secure communications by exchanging encryption 
      keys that are public and private in order to establish a secure line of 
      communication without. This describes any method that is used to do 
      secure key exchange.

** The Enigma Machine
   *Which two groups cracked it?* 
   
   A Polish group and a British group cracked the Enigma machine at different 
   times.
   
   The most well known codebreakers for the Polish group are Jerzy Rozycki, 
   Henryk Zygalski, and Marian Rejewski. These men were mathematicians that 
   were hired to work for the Polish General Staff's Cipher Bureau. Initially 
   mathematicians were not used to break code, but the Polish thought it 
   might be a good idea and tried it out. 

   The British later hired mathematicians to help with code breaking. As a 
   result, the British group came to consist of Alan Turing, Gordon Welchman, 
   and a few other people who also worked at Bletchley Park.
 
   *Who did it first?*
   
   The Polish group cracked the Enigma Machine first in 1932 while the British 
   group did not have success with cracking the Enigma Machine until 1940.
   
   *What is the method each group used?*
   
   The Polish group focused on a mathematical approach to break the Enigma 
   Machine. They first used the characteristics method to find patterns  
   from some of the German message senders. This helped them to be able to solve 
   the six permutations that the Germans used to encipher their messages or in 
   other words find the key to the cipher. No information was needed about the 
   machine in order to accomplish this. 

   Next they used the Theory of Permutations and Groups along with the help of 
   two German Engima manuals and two pages of monthly keys to find out how the 
   Enigma scrambler was wired. Rejewski later found that the military Enigma 
   that the Germans were using was not the same as the commercial Enigma they 
   had access to. As a result the ring and keyboard settings were different. 
   He guessed that the order was alphabetical and was correct. With this 
   information they were able to make replicas of the Engima machine called 
   "Enigma doubles". 

   Next they used the grill method to find the daily keys for the ciphers as 
   well as use this method to find the rightmost rotor and its position. The 
   grill method was also used to determine the plugboard wiring. They next set 
   out to use a cycle-length method instead of a grill method in order to find 
   cycles in the permutations. This resulted in them working to make a card 
   catalog to index the cycle-lengths which lead to the creation of a 
   cyclometer which was used to make the catalog. 

   When the characteristics method no longer worked for getting the message key, 
   they were able to use the Zygalski sheet method instead. This used perforated
   sheets to find the possible six wheel orders. This method uses the occurences
   of females. Females occur when the message key is given twice but is 
   enciphered differently and there is a letter that occurs twice and in the 
   same place as in the previous message key. For example, if the plaintext is 
   ABC and the cipher text (message key), being sent twice, is PCK ZEK 
   (PCK = ABC and ZEK = ABC), then a female has occurred because K showed up 
   twice and in the same position (third position in this case). 

   They later resorted to using an electro-mechanical device called the Bomba 
   which was invented by Rejewski. The Bomba used females to get key message, 
   but only needed an occurence of 3 females to uncode the message key instead 
   of the 10 females that the Zygalski sheet method needed to solve the same 
   problem. 

   
   The British group were given information from the Polish before the war 
   began. This greatly helped the British in breaking the Enigma machine. 
   Turing used the crib (known or guessed plaintext found in an encrypted 
   method) to solve the Enigma machine. The crib that was found would later 
   be used with an electro-mechanical device that Turing based off of the Bomba. 
   This machine would compare a crib to a ciphertext based off of the wheel 
   order that was set. Its function was to stop when a contradiction wasn't 
   present between the crib and the ciphertext. This would minimize the 
   possibilities to what the solution was and eventually lead to the "correct 
   plaintext of the whole message" [1]. 
   
   Turing also used probability analysis to estimate the "number of stops per 
   rotor order" [1] in order to avoid wasting time on menus (specified 
   relationship of the cib and ciphertext) that "were likely to yield to an 
   excessive number of false stops" [1]. Later Welchman invented a diagnol 
   board that increased the "number of steps needed for the codebreaking 
   effort" [2].

   Sources: 
   
   [1] https://en.wikipedia.org/wiki/Cryptanalysis_of_the_Enigma
   
   [2] http://www.cryptomuseum.com/crypto/bombe/index.htm

   [3] https://www.codesandciphers.org.uk/virtualbp/poles/poles.htm
   

** Password Strength Security
*** DONE Checker Implementation - ELISP
    CLOSED: [2018-06-14 Thu 21:52]

#+BEGIN_SRC elisp :results silent 
(defun upperp (p)
 (setq upper (upcase p))
  (string-equal upper p))
#+END_SRC

#+BEGIN_SRC elisp :results silent
(defun lowerp (p)
 (setq lower (downcase p))
  (string-equal lower p))
#+END_SRC

#+BEGIN_SRC elisp :results silent
(defun digitp (p)
 (or (string-equal "0" p)(string-equal "1" p)(string-equal "2" p)
      (string-equal "3" p)(string-equal "4" p)(string-equal "5" p)
      (string-equal "6" p)(string-equal "7" p)(string-equal "8" p)
      (string-equal "9" p)))
#+END_SRC

#+BEGIN_SRC elisp :results silent
(defun passwordCheck(p)
 (setq low 0)
 (setq up 0)
 (setq digit 0)
 (setq symb 0)
 (setq count 0)
 (setq checksPerSec 588235) 
 (while (< count (length p))
  (setq c (substring p count (+ count 1)))
  (if (lowerp c) (setq low 26)
   (if (upperp c) (setq up 26)
    (if (digitp c) (setq digit 10) (setq symb 33))))
  (incf count))
 (setq totalUniqueSymbols (+ low up digit symb))
 (setq numPermutations (expt totalUniqueSymbols (length p))) 
 (setq secondsToCrack (/ numPermutations checksPerSec))
 (setq halfSeconds (/ secondsToCrack 2))
 (setq secPerYear (* 525600 60))
 (setq years (/ halfSeconds secPerYear))
 (if (< years 1) "Very weak password" 
  (if (< years 25) "Weak password"
   (if (< years 50) "Average password"
    (if (< years 75) "Strong password" "Very Strong Password")))))
#+END_SRC

#+BEGIN_SRC elisp :results output
(print(passwordCheck "@ApplesAuce20&"))
#+END_SRC

#+RESULTS:
: 
: "Very Strong Password"

** Caesar Cipher
*** Implementation - ELISP
#+BEGIN_SRC elisp
(defun caesar (plainText key)
(setq alpha "abcdefghijklmnopqrstuvwxyz")
(setq encrypt "")
(setq num 0)
(while (< num (length plainText))
  (setq c (downcase (substring plainText num (+ num 1))))
  (setq start (% (+ (- (aref c 0) 97) key) (length alpha)))
  (setq encrypt (concat encrypt (substring alpha start (+ start 1))))
  (princ (substring encrypt num (+ num 1)))
  (incf num)))
#+END_SRC

#+RESULTS:
: caesar

#+BEGIN_SRC elisp :results output
(setq plainText "hello world")
(setq key 5)

(caesar plainText key)
#+END_SRC

#+RESULTS:
: mjqqtsbtwqi

#+BEGIN_SRC python :results output

# Paul's python stuff. Can be ignored.
def caesar(text, shift):
    abc = "a~b!c@d#e)f?g%h$i(.j;k l^m*n&o+=p{q]r}s[t,u<v> w\"x\'y\\z"
    cipher = {}


    for i in range(0, len(abc)):
        cipher[abc[i]] = abc[(i + shift) % len(abc)]

    cipherText = ""

    for c in text:
        cipherText += cipher[c]
    return cipherText

# This is to test the ceasar cipher
cipher_text = caesar("cout << \"hello world\" << endl;", 5)
print(cipher_text)
plain_text = caesar(cipher_text, -5)
print(plain_text)
#+END_SRC

#+RESULTS:
: )qw>y""yzj%&&qy\q,&?zy""y%p?&m
: cout << "hello world" << endl;

** Vigenere Cipher
*** Implementation - ELISP
#+BEGIN_SRC elisp
(defun vigenere (plainText key)

(setq alpha "abcdefghijklmnopqrstuvwxyz")
(setq encrypt "")

(setq num 0)
(while (< num (length plainText))
  (setq c (downcase (substring plainText num (+ num 1))))
  (setq shiftIt (% num (length key))) ;index of key that determines shift
  (setq shift (- (aref  key shiftIt) 97)) ;amount to shift plainText by
  (setq start (% (+ (- (aref c 0) 97) shift) 26)) ;index of alpha
  (setq encrypt (concat encrypt (substring alpha start (+ start 1))))
  (princ (substring encrypt num (+ num 1)))
  (incf num))
)
#+END_SRC

#+RESULTS:
: vigenere

#+BEGIN_SRC elisp :results output 
(setq plainText "HelloMyNameIsInigo")
(setq key "abcdef")

(vigenere plainText key)
#+END_SRC

#+RESULTS:
: hfnosryocpinsjplkt

** RSA Theory and Understanding
*** Number Theory Principles Involved
    

* Option 1
  *Modern Software Applications*
  
  Purpose - apply discrete mathematics directly into a current industry and 
  build a portfolio worthy project.
 
** Caesar or Vigenere Cipher Proof of Insecurity
** One Other Classic Cipher
*** Trifid - Kathryn Hollingshead and Paul Land
    -Research
    
    -Theory
    
    -Implementation
    
*** Myszkowski - Justin Bengtson and Nicki Caswell
    -Research
    
    -Theory
    
    -Implementation
    
*** Nicodemus - Taylor Matheny and Ryan Davis
    -Research
    
    -Theory
    
    -Implementation

** RSA
*** Implementation (C++ or Python)
*** Questions with Solutions
*** Key Terms
*** Examples

** AES
   What is this and how does it work?

** Cryptanalysis
   Decipher two cipher texts using an algorithm.
